// ============================================================
// SLiM WF standing-variation sweep (tick-based; replicate-friendly)
//
// - WF diploid Ne = 150,000
// - L = 50,000 bp; uniform recombination
// - mu = 2.04e-9 per bp per generation
// - Tree-sequence recording enabled
// - Neutral burn-in for 1,50,000 ticks
// - At t1 (=BURNIN): sample 8 diploid individuals (VCF), do not remove
//                    then pick ONE random segregating mutation anywhere in genome
//                    and begin positive selection on that allele (standing variation)
// - At t2 (=t1+T2_OFFSET): sample 8 diploids (VCF), output .trees, finish
//
// Run:
//   slim -d run_id=1 -d seed=100 n_replicates.slim
// ============================================================


// ------------------------------
// initialize()
// ------------------------------
initialize() {
    if (!exists("run_id")) defineConstant("RUN_ID", 1);
    else                   defineConstant("RUN_ID", asInteger(run_id));

    if (exists("seed"))
        setSeed(asInteger(seed));

    // Parameters
    defineConstant("Ne",         150000);
    defineConstant("L",          50000);
    defineConstant("MU",         2.04e-9);
    defineConstant("R",          1.0e-8);
    defineConstant("BURNIN",     1500000);
    // Require sel_s to be provided from the command line as: -d sel_s=...
    if (!exists("sel_s"))
        stop("ERROR: sel_s must be provided, e.g. slim -d sel_s=0.05 ...");

    defineConstant("SEL_S", asFloat(sel_s));
    if (!exists("decline_rate"))
        stop("ERROR: decline_rate must be provided, e.g. slim -d decline_rate=0.95 ...");
    defineConstant("DECLINE_RATE", asFloat(decline_rate));  // 5% decline per generation
    defineConstant("MIN_N", 50);          // choose whatever floor you want
    defineConstant("DOM_H",      1);
    defineConstant("SAMPLE_N",   8);
    defineConstant("T2_OFFSET",  5);   // t2 = t1 + 5 ticks

    // Outputs
    defineConstant("VCF_T1",     "sample_t1_run" + RUN_ID + ".vcf");
    defineConstant("VCF_T2",     "sample_t2_run" + RUN_ID + ".vcf");
    defineConstant("TREES_OUT",  "simulation_run" + RUN_ID + ".trees");

    // Model + tree sequence
    initializeSLiMModelType("WF");
    initializeTreeSeq();

    // Rates
    initializeMutationRate(MU);
    initializeRecombinationRate(R);

    // Single neutral mutation type across genome
    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, L - 1);

    // Globals set at t1
    defineGlobal("SELECTION_ON", F);
    defineGlobal("SELECTED_MUT", NULL);
}


// ------------------------------
// Create the population
// ------------------------------
1 early() {
    sim.addSubpop("p1", Ne);
}

early() {
    t = community.tick;

    if (t % 1000 == 0) {
        catn("RUN " + RUN_ID + ": tick " + t + " / " + BURNIN);
    }
}

// ------------------------------
// Population decline after T1
// ------------------------------
(BURNIN+1):(BURNIN+T2_OFFSET) early() {
    curN = p1.individualCount;
    newN = asInteger(round(curN * DECLINE_RATE));

    // optional floor to avoid extinction
    if (newN < MIN_N)
        newN = MIN_N;

    p1.setSubpopulationSize(newN);

    if ((community.tick - BURNIN) % 10 == 0) {
        catn("RUN " + RUN_ID + ": tick " + community.tick +
             " population size = " + newN);
    }
}

BURNIN late() {
    // sample t1
    p1.outputVCFSample(SAMPLE_N, replace=F, filePath=VCF_T1, append=F);

    // pick candidates with freq > MINF and < 1
    muts = sim.mutations;
    freqs = sim.mutationFrequencies(p1, muts);
    contenders = muts[freqs >= 0.10 & freqs < 1.0];

    if (size(contenders) == 0) {
        catn("RUN " + RUN_ID + ": No contender found (freq>=0.10).");
        // Option A: stop and restart externally
        sim.simulationFinished();
        return;
    }

    SELECTED_MUT = sample(contenders, 1);
    SELECTED_MUT.setSelectionCoeff(SEL_S);

    f0 = sim.mutationFrequencies(p1, SELECTED_MUT);
    catn("RUN " + RUN_ID + ": picked mut at " + SELECTED_MUT.position +
         " freq=" + f0 + " set s=" + SELECTED_MUT.selectionCoeff);
}

(BURNIN+1):(BURNIN+T2_OFFSET) late() {
    // optional: track trajectory every 50 ticks
    if ((community.tick - BURNIN) % 50 == 0) {
        if (!isNULL(SELECTED_MUT)) {
            f = sim.mutationFrequencies(p1, SELECTED_MUT);
            catn("RUN " + RUN_ID + ": tick " + community.tick + " selected freq=" + f);
        }
    }
}

(BURNIN + T2_OFFSET) late() {
    // sample t2
    p1.outputVCFSample(SAMPLE_N, replace=F, filePath=VCF_T2, append=F);

    // report outcome
    if (isNULL(SELECTED_MUT)) {
        catn("RUN " + RUN_ID + ": no selected mutation (none chosen).");
    } else {
        f1 = sim.mutationFrequencies(p1, SELECTED_MUT);
        catn("RUN " + RUN_ID + ": selected freq at t2=" + f1 +
             " s=" + SELECTED_MUT.selectionCoeff);
    }

    sim.simulationFinished();
}
